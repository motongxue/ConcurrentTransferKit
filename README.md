# 文件传输项目

本项目旨在提供高效且可靠的文件传输解决方案，从多个角度考虑了文件传输的不同方面，包括**分片传输、断点续传和文件秒传**
。这些功能的实现可以提供更好的用户体验、带宽利用率和数据完整性。

## 系统功能

- 分片传输：我们允许用户将大文件分成小块（分片）进行传输，以降低传输失败的风险。
- 断点续传：当传输过程中出现网络中断或者其他原因导致传输失败时，我们可以从上次传输失败的分片开始重新传输，而不需要重新传输整个文件。
- 文件秒传：当用户传输的文件已经存在于服务器上时，我们可以直接跳过传输过程，从而节省时间和带宽。
- 并发传输：我们可以利用goroutine实现并发，同时传输多个文件，从而提高带宽利用率和传输效率。
- 文件合并：防止服务器宕机导致的文件合并失败，我们可以在文件合并过程中使用redis的互斥锁，从而保证文件合并的原子性。

## 项目结构

- models/：包含FileMetaData和FileFragment结构的定义。
- client/：客户端代码，负责将文件分割成片段并发送给服务器。
- server/：服务器代码，负责接收客户端发送的片段并重新组装文件。
- conf/: 配置文件
- test_in/: 测试输入文件
- test_out/: 测试输出文件
- utils/: 相关工具

## 如何使用

在conf目录下，修改application.yaml中的相关配置，并在服务端运行server/main.go，客户端运行client/main.go即可。

## 如何工作

1. 客户端将待传输的文件拆分成多个片段，每个片段将被封装成FileFragment结构，并通过网络发送给服务器。
2. 服务器接收这些片段，并将它们按照顺序重新组装成原始文件。
3. 项目中的FileMetaData结构用于记录文件的信息，如文件名、哈希值、大小等。

## 项目存在的问题/难点

1. 多线程使用同一文件指针时存在并发问题
2. 文件分片的范围和文件指针的写入范围需要单独的判断
3. 需要同时使用http和tcp连接，其中http连接采用协程启动
4. 使用WaitGroup进行阻塞和等待
5. 由于是大文件传输，所以每个分片的传输都是一个tcp客户端请求（采用UDP看起来更快，但我们传的是文件需要对其进行可靠传输）->
   由于是大文件，所以不能一次性从网络io流中读入，需要使用buffer进行缓冲读取。每次客户端发送前，还事先发送自己的分片信息给服务端（用来标识是自己是哪一个分片）
6. 每次发送请求时，都查询服务端所拥有的文件分片，从而实现断点续传
7. 对redis、json序列化的相关操作
8. 文件的操作：目录创建、目录下的所有文件、文件的读写，io.Copy()
9. 当分片全部接收完成时，需要有一个协程进行文件的合并，此时也存在并发问题：利用redis的互斥锁来实现
10. redis的聚合类型（set、list、zset等）为空时，会自动将key删除：在FileMetaData中，记录所有文件分片是否接收成功的字段，从而解决这个问题
11. 参数传递的过程中，值传递导致调用函数和被调用函数用的不是同一个WaitGroup，导致调用函数陷入死锁，一直在Wait：解决方法：使用引用传递
12. 文件合并过程中，存在服务器宕机，则需要重新合并，添加合并后的结束标识
13. 生成.csv文件时，需写入UTF-8 BOM表头，避免使用excel软件打开.csv文件出现中文乱码`writer.WriteString("\xEF\xBB\xBF")`

## 结果验证

1. 文件信息一致性验证：文件名、文件大小、文件哈希值
2. 文件传输分片的完整性验证：文件分片的数量、文件分片的大小
3. 文件分片传输受损：将不记录为传输成功
4. 文件断点续传：文件分片部分传输成功，则只重传失败的分片
5. 文件分片传输成功，但是文件合并失败
6. 文件妙传测试：文件已经存在，不再重复传输

## 许可证

这个项目使用MIT许可证。有关详细信息，请查看LICENSE文件。

## 贡献

如果您发现任何问题或有改进建议，请随时提出问题或提交拉取请求。

## 作者

[motongxue](https://github.com/motongxue)

## 感谢

感谢您使用文件传输示例项目！
这份项目介绍说明了项目的结构、工作原理以及一些注意事项。根据需要，您可以自定义和扩展该介绍。如果您有其他问题或需要进一步的信息，请随时提出。
