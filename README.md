# 文件传输项目
这个项目旨在展示如何使用Go编程语言以及自定义数据结构FileFragment和FileRecord来进行文件传输。我们提供了一个简单的客户端和服务器示例，演示了如何将文件拆分为片段并通过网络传输，然后在服务器端重新组装文件。

## 项目结构
- client/：包含客户端代码，用于将文件分成片段并将其发送到服务器。
- server/：包含服务器代码，用于接收客户端发送的文件片段并重新组装文件。
- models/：包含共享的代码，包括FileFragment和FileRecord定义。
## 如何工作
1. 客户端将待传输的文件拆分成多个片段，每个片段将被封装成FileFragment结构，并通过网络发送给服务器。
2. 服务器接收这些片段，并将它们按照顺序重新组装成原始文件。
3. 项目中的FileRecord结构用于记录文件的信息，如文件名、哈希值、大小等。

## 主要文件
- models/file.go：包含FileFragment和FileRecord结构的定义。
- client/main.go：客户端代码，负责将文件分割成片段并发送给服务器。
- server/main.go：服务器代码，负责接收客户端发送的片段并重新组装文件。

## 项目存在的问题/难点
1. 多线程使用同一文件指针时存在并发问题
2. 文件分片的范围和文件指针的写入范围需要单独的判断
3. 需要同时使用http和tcp连接，其中http连接采用协程启动
4. 使用WaitGroup进行阻塞和等待
5. 由于是大文件传输，所以每个分片的传输都是一个tcp客户端请求（采用UDP看起来更快，但我们传的是文件需要对其进行可靠传输）->由于是大文件，所以不能一次性从网络io流中读入，需要使用buffer进行缓冲读取。每次客户端发送前，还事先发送自己的分片信息给服务端（用来标识是自己是哪一个分片）
6. 每次发送请求时，都查询服务端所拥有的文件分片，从而实现断点续传（待验证）
7. 对redis、json序列化的相关操作
8. 文件的操作：目录创建、目录下的所有文件、文件的读写，io.Copy()
9. 当分片全部接收完成时，需要有一个协程进行文件的合并，此时也存在并发问题：利用redis的互斥锁来实现。
10. redis的聚合类型（set、list、zset等）为空时，会自动将key删除，我们利用互斥锁，对该key添加元素-1，用来表示该文件已经传输成功了，用来实现文件秒传。

## 注意事项
1. 这个项目仅为演示目的，不包括安全性和错误处理等关键功能。在实际应用中，需要添加适当的错误处理和安全性措施。 
2. 文件传输示例中使用的片段大小和网络传输协议是简化的示例，可能需要根据实际需求进行调整和改进。
3. 该分支并未实现真正的文件分片并发传输，只是将文件分成多个片段，然后按顺序发送给服务器。只是在server端接收client端连接时，采用了goroutine并发处理。

## 许可证
这个项目使用MIT许可证。有关详细信息，请查看LICENSE文件。

## 贡献
如果您发现任何问题或有改进建议，请随时提出问题或提交拉取请求。

## 作者
[motongxue](https://github.com/motongxue)

## 感谢
感谢您使用文件传输示例项目！
这份项目介绍说明了项目的结构、工作原理以及一些注意事项。根据需要，您可以自定义和扩展该介绍。如果您有其他问题或需要进一步的信息，请随时提出。